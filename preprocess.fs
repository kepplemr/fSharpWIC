// PREPROCESS file - handles the preprocessing of the WIC code. From accepting user input, saving the lines of code to a list, and initializing
//                     required components to be utilized later on in the process.
// Author: Michael Kepple
// Date: Oct 13th, 2011
module preprocess

open System;
open System.IO;
open System.Collections.Generic;
open System.Windows.Forms;
open instructions;
open table;

// Function: readFile
// Description: Opens a Windows form box that allows the user to select the WIC file that they would like to interpret. After the user
//                selects a file the method scans the selected text file, saving each line of code as an entry in a list.
// Params: None, functionality determined by user input.
// Returns: List containing the lines of code read from the file.
// Modifies: Nothing.
let readFile =
    let ofd = new OpenFileDialog() in ofd.Title <- "Open a WIC File";
    if ofd.ShowDialog() = DialogResult.OK then
        Array.toList(File.ReadAllLines(ofd.FileName))
    else
        []

// Function: processInput
// Description: Takes the input list generated by readFile and seperates it into a formatted tuple of Opcode, Operand that will be much
//                easier to work with later on in the process.
// Params: The list created by previous call to readFile
// Returns: Formatted list of string tuple in the form (Opcode, Operand)
// Modifies: Nothing
let rec processInput list =
    match list with
    | [] -> []
    | hd::tl -> let ary = (hd:string).Split(' ')
                try
                  // Allow for line comments!
                  if (ary.[0] <> "|") then
                    (ary.[0], ary.[1])::processInput tl
                  else
                     processInput tl
                with
                  | :? Exception -> (ary.[0], null)::processInput tl


// Initialize jumpTable
let jumpTable = [];;

// Function: createJT
// Description: On the first run through the formatted code, we look for nop instructions indicating the presense of a Label on that line
//                that we need to save to the jump table. Upon encountering one of these labels we call the store method in table and 
//                continue to recurse through the file looking for more Labels.
// Params: List of code lines and the Program Counter
// Returns: Nothing
// Modifies: The jump table
let rec createJT list pc = 
    match list with
    | [] -> []
    | hd::tl -> if((fst hd) = "nop") then (store (snd hd) pc jumpTable)@createJT tl (pc+1)
                elif ((snd hd) = "label") then (store (fst hd) pc jumpTable)@createJT tl (pc+1)
                else createJT tl (pc+1);;